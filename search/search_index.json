{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Lenguaje A3","text":"<p>Bienvenido a la documentaci\u00f3n oficial del lenguaje de programaci\u00f3n A3. A3 es un lenguaje compacto de estilo C pensado para fines educativos y dise\u00f1ado para ejecutarse sobre la m\u00e1quina virtual TinyVM en robots basados en ESP32. Se enfoca en:</p> <ul> <li>Sem\u00e1ntica predecible sustentada por una gram\u00e1tica determinista construida con Flex/Bison.</li> <li>Integraci\u00f3n estrecha con TinyVM, utilizando opcodes para aritm\u00e9tica, control de flujo y traps de hardware.</li> <li>Sintaxis accesible para estudiantes que aprenden programaci\u00f3n imperativa, arreglos y composici\u00f3n de funciones.</li> </ul>"},{"location":"#panorama-rapido","title":"Panorama R\u00e1pido","text":"Categor\u00eda Caracter\u00edsticas Tipos <code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, arreglos unidimensionales Operadores Aritm\u00e9ticos (+, -, *, /, %), l\u00f3gicos (and, or, not), comparaciones (==, !=, &lt;, &gt;, &lt;=, &gt;=) Control de flujo <code>if/else</code>, <code>while</code>, <code>for</code> con sintaxis tipo C Funciones Declaraciones <code>proc</code> con par\u00e1metros tipados y <code>return</code> E/S y hardware <code>exec</code> para invocar funciones externas o integradas en TinyVM para sensores, motores y SD"},{"location":"#ejemplo-minimo","title":"Ejemplo M\u00ednimo","text":"<pre><code>int proc main() start\n    int counter = 0;\n\n    while (counter &lt; 5) start\n        exec print(counter);\n        counter = counter + 1;\n    end\n\n    return counter;\nend\n</code></pre> <p>Este programa incrementa un contador, imprime los valores intermedios mediante un trap de la VM y devuelve el resultado final.</p>"},{"location":"#mapa-de-la-documentacion","title":"Mapa de la Documentaci\u00f3n","text":"<p>El resto del sitio se organiza as\u00ed:</p> <ol> <li>Primeros Pasos \u2014 requisitos del toolchain, compilaci\u00f3n y ejecuci\u00f3n en TinyVM.</li> <li>Referencia del Lenguaje \u2014 gram\u00e1tica completa, tokens l\u00e9xicos, reglas de tipos y sem\u00e1ntica.</li> <li>Integraci\u00f3n con la VM \u2014 mapeo de construcciones A3 hacia instrucciones y traps de TinyVM, adem\u00e1s del layout en tiempo de ejecuci\u00f3n.</li> <li>Herramientas \u2014 extensiones de IDE, utilidades de prueba y flujos de trabajo para extender el lenguaje.</li> </ol> <p>Usa la barra lateral de navegaci\u00f3n para saltar a cualquier secci\u00f3n. Cada p\u00e1gina incluye enlaces cruzados hacia el material de referencia relevante para facilitar la exploraci\u00f3n.</p>"},{"location":"getting-started/","title":"Primeros Pasos","text":"<p>Esta gu\u00eda describe c\u00f3mo instalar las dependencias, compilar la cadena de herramientas y ejecutar programas A3 sobre TinyVM.</p>"},{"location":"getting-started/#prerrequisitos","title":"Prerrequisitos","text":"<p>Instala los siguientes paquetes (nombres para Debian/Ubuntu):</p> <pre><code>sudo apt-get update\nsudo apt-get install build-essential flex bison python3 python3-pip\n</code></pre> <p>Si deseas flashear TinyVM a una placa ESP32, tambi\u00e9n necesitar\u00e1s el IDE de Arduino o <code>arduino-cli</code>.</p>"},{"location":"getting-started/#estructura-del-repositorio","title":"Estructura del Repositorio","text":"<pre><code>TLP_proyecto/\n\u251c\u2500\u2500 language/          # L\u00e9xico, parser, sem\u00e1ntica, AST y traductor\n\u251c\u2500\u2500 vm/                # Firmware TinyVM para ESP32\n\u2514\u2500\u2500 docs/              # Fuentes de documentaci\u00f3n MkDocs\n</code></pre>"},{"location":"getting-started/#compilar-la-cadena-de-herramientas","title":"Compilar la Cadena de Herramientas","text":"<p>Entra al directorio <code>language</code> y ejecuta el Makefile:</p> <pre><code>cd language\nmake clean\nmake\n</code></pre> <p>Artefactos resultantes:</p> <ul> <li><code>a3c</code> \u2014 compilador para programas <code>.a3</code> y genera bytecode TinyVM (<code>.vmcode</code>).</li> </ul>"},{"location":"getting-started/#traducir-un-programa","title":"Traducir un Programa","text":"<ol> <li>Escribe tu programa (por ejemplo, <code>program.a3</code>).</li> <li> <p>Ejecuta el compilador para verificar la sintaxis y generar el bytecode:</p> <p><code>bash ./a3c &lt; program.a3</code></p> </li> <li> <p>Copia <code>program.vmcode</code> a la tarjeta SD usada por TinyVM (ruta predeterminada <code>/program.vmcode</code>).</p> </li> </ol>"},{"location":"getting-started/#desplegar-en-tinyvm","title":"Desplegar en TinyVM","text":"<ol> <li>Abre <code>vm/vm_complete.ino</code> en Arduino IDE.</li> <li>Ajusta <code>VMCODE_FILE</code> o el cableado SD si tu hardware difiere.</li> <li>Flashea el firmware a la ESP32.</li> <li>Inserta la SD con <code>program.vmcode</code> y reinicia la placa.</li> <li>Usa el monitor serie (115200 baudios) para ver depuraci\u00f3n, dumps de registros y traps.</li> </ol>"},{"location":"getting-started/#usar-la-extension-de-vs-code","title":"Usar la Extensi\u00f3n de VS Code","text":"<p>En el marketplace de VS Code puedes descargar la extensi\u00f3n A3 Linter para que tus programas sean mucho m\u00e1s f\u00e1cil de escribir.</p> <p></p>"},{"location":"language-reference/","title":"Referencia del Lenguaje","text":"<p>Este cap\u00edtulo describe la sintaxis y la sem\u00e1ntica del lenguaje TLP. La especificaci\u00f3n coincide con la gram\u00e1tica implementada en <code>gramatica</code>, <code>lexer.l</code> y las rutinas de an\u00e1lisis sem\u00e1ntico ubicadas en <code>language/</code>.</p>"},{"location":"language-reference/#estructura-lexica","title":"Estructura L\u00e9xica","text":"<ul> <li>Identificadores: comienzan con una letra y pueden contener letras, d\u00edgitos o <code>_</code>.</li> <li>Literales:<ul> <li>Enteros: d\u00edgitos decimales (<code>42</code>, <code>0</code>, <code>1024</code>).</li> <li>Dobles: d\u00edgitos con punto decimal (<code>3.14</code>).</li> <li>Caracteres: comillas simples (<code>'a'</code>).</li> <li>Booleanos: <code>true</code>, <code>false</code>.</li> </ul> </li> <li>Comentarios: <code>// comentario de l\u00ednea</code> y <code>/* comentario de bloque */</code>.</li> </ul>"},{"location":"language-reference/#palabras-reservadas","title":"Palabras Reservadas","text":"<p><code>int</code>, <code>float</code>, <code>char</code>, <code>bool</code>, <code>void</code>, <code>proc</code>, <code>return</code>, <code>if</code>, <code>else</code>, <code>for</code>, <code>while</code>, <code>start</code>, <code>end</code>, <code>exec</code>.</p>"},{"location":"language-reference/#tipos","title":"Tipos","text":"Tipo Descripci\u00f3n Valor por defecto <code>int</code> Entero con signo de 32 bits <code>0</code> <code>float</code> Flotante de 64 bits (se descompone en dos registros en la VM) <code>0.0</code> <code>char</code> Car\u00e1cter de 8 bits almacenado como <code>int</code> <code>0</code> <code>bool</code> Booleano almacenado como <code>0</code>/<code>1</code> <code>false</code> <code>T[]</code> Arreglo unidimensional del tipo <code>T</code> Inicializado en cero <p>Los arreglos se definen con una longitud constante en tiempo de compilaci\u00f3n y pueden inicializarse mediante listas literales. Solo se admite una dimensi\u00f3n en la gram\u00e1tica y en el runtime actual de la VM.</p>"},{"location":"language-reference/#resumen-de-la-gramatica","title":"Resumen de la Gram\u00e1tica","text":"<pre><code>Programa -&gt; Bloque Programa | Declaracion_funcion Programa | \u03bb\nDeclaracion_funcion -&gt; TIPO FUNCTION ID ( Parametros_funcion ) Bloque\nParametros_funcion -&gt; TIPO ID Parametros_funcion_aux | \u03bb\nParametros_funcion_aux -&gt; , TIPO ID Parametros_funcion_aux | \u03bb\nRetorno_funcion -&gt; RETURN Expresion\nBloque -&gt; START BloqueAux END\nBloqueAux -&gt; Instruccion BloqueAux | \u03bb\nInstruccion -&gt; Asignacion ; | Declaracion ; | For | While | If | Exec_funcion ; | Retorno_funcion ;\n...\n</code></pre> <p>La gram\u00e1tica contin\u00faa con producciones para expresiones, precedencias e indexaciones de arreglos, tal como se detalla en <code>/gramatica</code>. La precedencia de operadores sigue el orden del archivo: unarios <code>!</code>/<code>-</code>, multiplicativos <code>* / %</code>, aditivos <code>+ -</code>, comparaciones, <code>&amp;&amp;</code>, <code>||</code>.</p>"},{"location":"language-reference/#sentencias","title":"Sentencias","text":""},{"location":"language-reference/#declaraciones","title":"Declaraciones","text":"<pre><code>int counter;\nfloat velocity = 0.0;\nbool flags[4];\n</code></pre> <ul> <li>Inicializaci\u00f3n opcional mediante expresiones o literales de arreglo: <code>int data[3] = [1,2,3];</code>.</li> <li>La longitud de los arreglos debe ser un literal entero conocido en compilaci\u00f3n.</li> </ul>"},{"location":"language-reference/#asignaciones","title":"Asignaciones","text":"<pre><code>counter = counter + 1;\ndata[2] = counter;\ndata = [0, 1, 2];\n</code></pre> <p>Los literales de arreglo deben coincidir con la longitud declarada.</p>"},{"location":"language-reference/#control-de-flujo","title":"Control de Flujo","text":"<pre><code>if (sensor &gt; threshold) start\n    exec forward_ms(250);\nend else start\n    exec stopMotors();\nend\n\nwhile (i &lt; 10) start i = i + 1; end\n\nfor (int j = 0; j &lt; size; j = j + 1) start\n    sum = sum + values[j];\nend\n</code></pre> <p>Cada ciclo se traduce a saltos y comparaciones en TinyVM; consulta Integraci\u00f3n con la VM para m\u00e1s detalles.</p>"},{"location":"language-reference/#funciones","title":"Funciones","text":"<pre><code>int proc add(int a, int b) start\n    return a + b;\nend\n</code></pre> <ul> <li>Los argumentos se pasan por valor mediante la pila de TinyVM.</li> <li><code>return</code> abandona la funci\u00f3n y coloca el valor en el registro <code>R6</code>.</li> </ul>"},{"location":"language-reference/#llamadas-integradas","title":"Llamadas Integradas","text":"<p><code>exec</code> invoca traps de TinyVM (definidos en <code>vm_complete.ino</code>). Los argumentos se eval\u00faan antes de ejecutar el trap:</p> <pre><code>exec digitalWrite(pin, value);\nexec print(counter);\n</code></pre>"},{"location":"language-reference/#funciones-predefinidas-disponibles-via-exec","title":"Funciones predefinidas disponibles v\u00eda <code>exec</code>","text":"Nombre Descripci\u00f3n breve <code>digitalRead</code> Lee el estado l\u00f3gico de un pin digital configurado como entrada. <code>digitalWrite</code> Escribe <code>HIGH</code>/<code>LOW</code> en un pin digital configurado como salida. <code>analogRead</code> Devuelve la lectura ADC del pin configurado para entradas anal\u00f3gicas. <code>pwmWrite</code> Genera una se\u00f1al PWM en el pin indicado con el ciclo de trabajo proporcionado. <code>pinMode</code> Configura un pin como <code>INPUT</code>, <code>OUTPUT</code> u otros modos compatibles con TinyVM. <code>print</code> Env\u00eda al puerto serie el valor evaluado, \u00fatil para depuraci\u00f3n. <code>forward_ms</code> Hace avanzar el robot, recibe un par\u00e1metro de tipo entero que indica la cantidad de milisegundos indicada que se movera sin embargo actualmente no se soporta la cantidad de milisegundos por lo que el robot se mueve indefinidamente sin importar el valor del par\u00e1metro. <code>back_ms</code> Hace retroceder el robot, recibe un par\u00e1metro de tipo entero que indica la cantidad de milisegundos indicada que se movera sin embargo actualmente no se soporta la cantidad de milisegundos por lo que el carro se mueve indefinidamente sin importar el valor del par\u00e1metro indicados. <code>turnLeft_ms</code> Ordena un giro a la izquierda, recibe un par\u00e1metro de tipo entero que indica la cantidad de milisegundos indicada que se movera sin embargo actualmente no se soporta la cantidad de milisegundos por lo que el carro se mueve indefinidamente sin importar el valor del par\u00e1metro. <code>turnRight_ms</code> Ordena un giro a la derecha, recibe un par\u00e1metro de tipo entero que indica la cantidad de milisegundos indicada que se movera sin embargo actualmente no se soporta la cantidad de milisegundos por lo que el carro se mueve indefinidamente sin importar el valor del par\u00e1metro. <code>readLeftSensor</code> Devuelve la \u00faltima lectura del sensor montado en el lado izquierdo en el pin 35 <code>readRightSensor</code> Devuelve la lectura del sensor montado en el lado derecho en el pin 34. <p>Cada invocaci\u00f3n mediante <code>exec nombre(arg1, arg2, ...)</code> eval\u00faa todos los argumentos antes de tocar hardware y se traduce a la instrucci\u00f3n <code>TRAP</code> correspondiente en TinyVM.</p>"},{"location":"language-reference/#expresiones","title":"Expresiones","text":"<ul> <li>Unarios: <code>-x</code>, <code>not flag</code>.</li> <li>Aritm\u00e9tica binaria: <code>+ - * / %</code>.</li> <li>Comparaciones: <code>== != &lt; &lt;= &gt; &gt;=</code>.</li> <li>L\u00f3gicos: <code>and or</code> (el traductor aplica cortocircuito).</li> <li>Par\u00e9ntesis para agrupar expresiones.</li> </ul>"},{"location":"language-reference/#manejo-de-errores","title":"Manejo de Errores","text":"<p>El analizador sem\u00e1ntico verifica:</p> <ul> <li>Compatibilidad de tipos en asignaciones y operaciones.</li> <li>L\u00edmites de arreglos en tiempo de compilaci\u00f3n para inicializadores literales y en tiempo de ejecuci\u00f3n para accesos indexados.</li> <li>Firmas de funciones (definiciones duplicadas, aridad y tipos de par\u00e1metros).</li> </ul> <p>Los diagn\u00f3sticos incluyen l\u00ednea y columna, y se muestran durante la traducci\u00f3n.</p> <p>Contin\u00faa con Integraci\u00f3n con la VM para conocer la representaci\u00f3n de bajo nivel de estas construcciones.</p>"},{"location":"tooling/","title":"Herramientas y Flujo de Trabajo","text":"<p>A3 incluye utilidades auxiliares para agilizar el desarrollo, las pruebas y la documentaci\u00f3n.</p>"},{"location":"tooling/#utilidades-de-linea-de-comandos","title":"Utilidades de L\u00ednea de Comandos","text":"Binario Ubicaci\u00f3n Descripci\u00f3n <code>a3c</code> <code>language/</code> Valida la correcci\u00f3n l\u00e9xica y sint\u00e1ctica y emite bytecode de TinyVM. <code>integration_tests.py</code> ra\u00edz del repo Ejecuta regresiones para parser y traductor. <p>Flujo de trabajo t\u00edpico:</p> <pre><code>cd language\nmake\n./a3c &lt; test.a3\n</code></pre>"},{"location":"tooling/#extension-de-vs-code","title":"Extensi\u00f3n de VS Code","text":"<p><code>linter/</code> contiene una gram\u00e1tica TextMate empaquetada como extensi\u00f3n para VS Code:</p> <p>En el marketplace de VS Code puedes descargar la extensi\u00f3n A3 Linter para que tus programas sean mucho m\u00e1s f\u00e1cil de escribir.</p>"},{"location":"tooling/#documentacion","title":"Documentaci\u00f3n","text":"<p>Este sitio MkDocs vive en <code>docs/</code> con configuraci\u00f3n en <code>mkdocs.yml</code>. Para contribuir:</p> <pre><code>pip install mkdocs mkdocs-material\nmkdocs serve\n</code></pre> <p>Edita los archivos Markdown en <code>docs/</code>; MkDocs recarga los cambios en vivo en <code>http://127.0.0.1:8000</code>.</p>"},{"location":"tooling/#pruebas-y-ci","title":"Pruebas y CI","text":"<ul> <li><code>integration_tests.py</code> puede integrarse en CI para asegurar que las nuevas caracter\u00edsticas del lenguaje compilan y se traducen.</li> <li>Es posible a\u00f1adir pruebas unitarias alrededor de TinyVM (<code>vm/</code>) compilando con <code>#define UNIT_TESTING</code> para aislar las dependencias de Arduino.</li> </ul>"},{"location":"tooling/#flujo-sugerido","title":"Flujo Sugerido","text":"<ol> <li>Dise\u00f1o: Actualiza <code>gramatica</code> y las comprobaciones sem\u00e1nticas.</li> <li>Implementaci\u00f3n: Ajusta <code>translator.c</code> para emitir los nuevos opcodes.</li> <li>Regresiones: Ejecuta las pruebas de compilador y, si aplica, flashea TinyVM con el nuevo bytecode.</li> <li>Documentaci\u00f3n: Agrega o modifica secciones de este sitio para capturar las nuevas caracter\u00edsticas.</li> </ol> <p>Mantener la documentaci\u00f3n junto con la implementaci\u00f3n ayuda a que estudiantes y colaboradores sigan la evoluci\u00f3n del lenguaje.</p>"},{"location":"vm-integration/","title":"Integraci\u00f3n con la VM","text":"<p>Esta secci\u00f3n describe c\u00f3mo las construcciones de alto nivel de TLP se mapean al conjunto de instrucciones y al runtime de TinyVM detallado en <code>vm/vm_complete.ino</code> y <code>vm/vm_architecture.md</code>.</p>"},{"location":"vm-integration/#modelo-de-memoria-en-ejecucion","title":"Modelo de Memoria en Ejecuci\u00f3n","text":"<p>TinyVM reserva:</p> <ul> <li>Registros (<code>R0</code>-<code>R7</code>): prop\u00f3sito general con <code>R6</code> como registro de retorno.</li> <li>Pila (1 KB): evaluaci\u00f3n de expresiones, marcos de funciones y variables locales.</li> <li>Heap (2 KB): arreglos y buffers din\u00e1micos.</li> <li>Buffer de programa: bytecode cargado desde la tarjeta SD (<code>/program.vmcode</code>).</li> </ul> <p>El traductor asigna a cada variable declarada una ubicaci\u00f3n est\u00e1tica relativa al marco de pila o al heap. Los arreglos ocupan rangos contiguos indexados por el tama\u00f1o del elemento.</p>"},{"location":"vm-integration/#codificacion-de-instrucciones","title":"Codificaci\u00f3n de Instrucciones","text":"<p>Cada instrucci\u00f3n ocupa 3 bytes: opcode, <code>arg1</code>, <code>arg2</code>. Los saltos usan dos bytes (little-endian). Inmediatos m\u00e1s grandes emplean <code>LOADI16</code> para insertar palabras de 16 bits.</p> Construcci\u00f3n TLP Patr\u00f3n Emitido <code>a = b + c;</code> <code>LOAD R1, VAR_b</code> \u2192 <code>LOAD R2, VAR_c</code> \u2192 <code>ADD R1, R2</code> \u2192 <code>STORE VAR_a, R0</code> <code>if (cond) start end</code> Evaluar <code>cond</code>, emitir <code>JZ else_addr</code>, cuerpo, opcional <code>JMP end</code>, bloque else <code>while (cond)</code> Etiqueta inicio \u2192 evaluar \u2192 <code>JZ exit</code> \u2192 cuerpo \u2192 <code>JMP start</code> \u2192 etiqueta salida <code>for</code> Inicializaci\u00f3n \u2192 etiqueta bucle \u2192 condici\u00f3n + <code>JZ exit</code> \u2192 cuerpo \u2192 incremento \u2192 <code>JMP loop</code> <code>array[i]</code> lectura Evaluar <code>i</code>, sumar base, <code>LOADM target_reg, idx_reg</code> <code>array[i] = v</code> Evaluar <code>i</code> y <code>v</code>, calcular direcci\u00f3n, <code>STORE addr_reg, value_reg</code> <code>exec B_x(y)</code> Evaluar argumentos en registros y emitir <code>TRAP trap_id</code>"},{"location":"vm-integration/#banderas-y-comparaciones","title":"Banderas y Comparaciones","text":"<ul> <li><code>CMP Rx, Ry</code> establece las banderas zero/lt/gt/le/ge.</li> <li>Los saltos condicionales (<code>JZ</code>, <code>JNZ</code>, <code>JLT</code>, <code>JGT</code>, <code>JLE</code>, <code>JGE</code>) dependen de dichas banderas.</li> <li>Las expresiones booleanas aplican cortocircuito encadenando saltos y etiquetas para evitar evaluaciones innecesarias.</li> </ul>"},{"location":"vm-integration/#llamadas-a-funciones","title":"Llamadas a Funciones","text":"<ol> <li>Los argumentos se apilan de derecha a izquierda.</li> <li><code>CALL addr</code> guarda el PC de retorno (dos posiciones en la pila) y salta.</li> <li>La funci\u00f3n llamada reserva locales ajustando el puntero de pila.</li> <li><code>return expr;</code> coloca el valor en <code>R6</code>, restaura la pila y ejecuta <code>RET</code>.</li> <li>La funci\u00f3n que llama lee <code>R6</code> para obtener el resultado y desapila los argumentos si es necesario.</li> </ol>"},{"location":"vm-integration/#traps-de-hardware","title":"Traps de Hardware","text":"<p><code>TRAP opcode</code> despacha a <code>TinyVM::call_trap</code>, con soporte para:</p> <ul> <li>IO digital/anal\u00f3gico (<code>B_DIGITAL_READ</code>, <code>B_DIGITAL_WRITE</code>, <code>B_ANALOG_READ</code>).</li> <li>Control de motores (<code>B_FORWARD</code>, <code>B_BACK</code>, <code>B_TURN_LEFT</code>, <code>B_TURN_RIGHT</code>, <code>B_SET_SPEED</code>).</li> <li>Lectura de sensores (<code>B_READ_IR_LEFT</code>, <code>B_READ_IR_RIGHT</code>).</li> </ul> <p>Los argumentos se colocan convencionalmente en <code>R0</code>, <code>R1</code>, \u2026 antes de emitir la instrucci\u00f3n <code>TRAP</code>.</p>"},{"location":"vm-integration/#integracion-con-loop-de-arduino","title":"Integraci\u00f3n con <code>loop()</code> de Arduino","text":"<p>Cuando <code>vm_complete.ino</code> carga el bytecode, puede registrar la etiqueta <code>.loop</code> y ejecutar <code>TinyVM::runLoop()</code> dentro de <code>loop()</code>. Esto permite estructurar los programas como las funciones <code>setup</code> + <code>loop</code> t\u00edpicas de Arduino.</p> <p>Consulta <code>vm/vm_architecture.md</code> para profundizar en la definici\u00f3n de opcodes, marcos de pila y tiempos de ejecuci\u00f3n.</p>"}]}