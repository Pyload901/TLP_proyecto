# Compiler Design: From AST to VM Bytecode

This document describes how to compile your language grammar into VM bytecode for execution.

## 1. COMPILATION PIPELINE

```
Source Code
    │
    ▼
┌─────────────────┐
│  Lexer (Flex)   │  Tokenizes input
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Parser (Yacc)  │  Builds AST
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Semantic Analysis              │  Type checking, symbol resolution
│  - Symbol table                 │
│  - Type checking                │
│  - Scope management             │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  CODE GENERATION (NEW)          │  AST -> Bytecode
│  - Traverse AST                 │
│  - Emit instructions            │
│  - Allocate registers/stack     │
│  - Manage labels/jumps          │
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  OPTIMIZATION (Optional)        │  Peephole, dead code, const folding
└────────┬────────────────────────┘
         │
         ▼
┌─────────────────────────────────┐
│  Bytecode Assembly              │  Pack to 3-byte instructions
└────────┬────────────────────────┘
         │
         ▼
    Bytecode File
    (Save to SD card)
```

## 2. SYMBOL TABLE & VARIABLE ALLOCATION

### Data Structure

```cpp
struct Symbol {
  char name[32];
  enum { VAR, FUNC, PARAM } kind;
  enum { TYPE_INT, TYPE_CHAR, TYPE_BOOL, TYPE_DOUBLE, TYPE_ARRAY } type;

  // Storage location
  uint16_t location;  // Stack offset or register number
  bool in_register;   // Is it in R0-R7?
  bool is_array;
  uint16_t array_size;
};

struct Scope {
  Symbol* symbols;
  int symbol_count;
  Scope* parent;  // For nested scopes
  uint16_t local_var_size;  // Total bytes used by locals
};
```

### Variable Allocation Strategy

**Registers (R0-R5)**: Fast local variables (first 6 locals)

```
  R0: Local var 1
  R1: Local var 2
  R2: Local var 3
  R3: Local var 4
  R4: Local var 5
  R5: Local var 6
  R6: Accumulator (for return values)
  R7: Reserved (frame pointer)
```

**Stack (above FP)**: Additional locals and function frames

```
  FP + 0:  Previous FP
  FP + 4:  Arg 1
  FP + 8:  Arg 2
  ...
  FP - 4:  Local var 7
  FP - 8:  Local var 8
  ...
```

## 3. CODE GENERATION FOR LANGUAGE CONSTRUCTS

### 3.1 Variable Declaration

**Language:**

```c
int x;
```

**Generated Bytecode:**

```
Allocate register or stack location for x
```

**Code Generator Function:**

```cpp
void codegen_declaration(Node* decl_node, Emitter* emitter) {
  char* var_name = decl_node->left->value;
  char* type_str = decl_node->value;

  Symbol sym;
  strcpy(sym.name, var_name);

  if (current_scope->symbol_count < 6) {
    // Use register
    sym.location = current_scope->symbol_count;
    sym.in_register = true;
    emitter->emit_loadi(sym.location, 0);  // Init to 0
  } else {
    // Use stack
    sym.location = current_scope->local_var_size;
    sym.in_register = false;
    current_scope->local_var_size += 4;
  }

  add_symbol(current_scope, sym);
}
```

### 3.2 Assignment

**Language:**

```c
x = y + 5;
```

**Generated Bytecode:**

```
CODEGEN(y + 5) -> result in R0
LOAD R_x, R0          (move result to x's location)
```

**Code Generator:**

```cpp
void codegen_assignment(Node* assign_node, Emitter* emitter) {
  char* var_name = assign_node->left->value;
  Symbol* sym = lookup_symbol(current_scope, var_name);

  // Evaluate RHS into R0
  codegen_expression(assign_node->right, emitter);

  // Move result to target
  if (sym->in_register) {
    emitter->emit_load(sym->location, 0);  // R[location] = R0
  } else {
    // Store to stack
    emitter->emit_store_to_stack(sym->location, 0);
  }
}
```

### 3.3 Arithmetic Expression

**Language:**

```c
(a + b) * c
```

**Generated Bytecode:**

```
LOAD R0, R_a
LOAD R1, R_b
ADD R0, R1             (R0 = a + b)
LOAD R2, R_c
MUL R0, R2             (R0 = (a + b) * c)
```

**Code Generator (Recursive):**

```cpp
void codegen_binary_op(Node* bin_op, Emitter* emitter) {
  // Evaluate left operand
  codegen_expression(bin_op->left, emitter);    // Result in R0

  // Save R0 to temporary
  emitter->emit_push(0);  // Save R0

  // Evaluate right operand
  codegen_expression(bin_op->right, emitter);   // Result in R0

  // Restore left operand to R1
  emitter->emit_pop(1);   // Pop into R1

  // Perform operation
  if (strcmp(bin_op->value, "+") == 0) {
    emitter->emit_add(1, 0);  // R0 = R1 + R0
  } else if (strcmp(bin_op->value, "-") == 0) {
    emitter->emit_sub(1, 0);  // R0 = R1 - R0
  } else if (strcmp(bin_op->value, "*") == 0) {
    emitter->emit_mul(1, 0);  // R0 = R1 * R0
  } else if (strcmp(bin_op->value, "/") == 0) {
    emitter->emit_div(1, 0);  // R0 = R1 / R0
  }
  // Result in R0
}
```

### 3.4 Comparison & Conditional

**Language:**

```c
if (x > 5) {
  print(1);
} else {
  print(0);
}
```

**Generated Bytecode:**

```
LOAD R0, R_x
LOADI R1, 5
CMP R0, R1             (set flags)
JLE else_label         (jump if x <= 5)

[THEN BLOCK]
LOADI R0, 1
PRINT R0
JMP end_label

[ELSE BLOCK]
else_label:
LOADI R0, 0
PRINT R0

end_label:
```

**Code Generator:**

```cpp
void codegen_if(Node* if_node, Emitter* emitter) {
  // Generate condition evaluation
  codegen_expression(if_node->left, emitter);   // Result in R0 (zero/nonzero)

  // Emit conditional jump
  uint16_t else_label = emitter->new_label();
  uint16_t end_label = emitter->new_label();

  // If condition is false (R0 == 0), jump to else
  emitter->emit_jz(else_label);

  // Then branch
  codegen_block(if_node->right, emitter);

  // Jump over else
  emitter->emit_jmp(end_label);

  // Else branch
  emitter->emit_label(else_label);
  if (if_node->extra) {
    codegen_block(if_node->extra, emitter);
  }

  // End
  emitter->emit_label(end_label);
}
```

### 3.5 Loops

**Language:**

```c
for (int i = 0; i < 10; i++) {
  sum = sum + i;
}
```

**Generated Bytecode:**

```
LOADI R_i, 0           (init)

loop_label:
LOAD R0, R_i
LOADI R1, 10
CMP R0, R1             (i < 10?)
JGE exit_loop          (jump if i >= 10)

[LOOP BODY]
LOAD R0, R_sum
LOAD R1, R_i
ADD R0, R1
LOAD R_sum, R0

[INCREMENT]
LOAD R0, R_i
LOADI R1, 1
ADD R0, R1
LOAD R_i, R0

JMP loop_label

exit_loop:
```

**Code Generator:**

```cpp
void codegen_for(Node* for_node, Emitter* emitter) {
  // for_node->left: init
  // for_node->right: condition
  // for_node->extra: increment
  // for_node->list: body

  // Init
  codegen_statement(for_node->left, emitter);

  uint16_t loop_label = emitter->new_label();
  uint16_t exit_label = emitter->new_label();

  // Loop header
  emitter->emit_label(loop_label);

  // Condition
  codegen_expression(for_node->right, emitter);  // Result in R0 (1=true, 0=false)
  emitter->emit_jz(exit_label);  // Jump if condition false

  // Body
  codegen_block(for_node->list, emitter);

  // Increment
  codegen_expression(for_node->extra, emitter);

  // Jump back
  emitter->emit_jmp(loop_label);

  // Exit
  emitter->emit_label(exit_label);
}
```

### 3.6 Function Definition

**Language:**

```c
int add(int a, int b) {
  return a + b;
}
```

**Generated Bytecode:**

```
; Function table entry: address=0x1000
func_add:  0x1000

; Bytecode at 0x1000:
LOAD R0, R_a           (load arg a)
LOAD R1, R_b           (load arg b)
ADD R0, R1             (R0 = a + b)
LOAD R6, R0            (move result to R6 for return)
RET
```

**Code Generator:**

```cpp
void codegen_function(Node* func_node, Emitter* emitter) {
  char* func_name = func_node->value;
  uint16_t func_address = emitter->current_offset();

  // Add to function table
  register_function(func_name, func_address);

  // Push new scope for function
  Scope* func_scope = new_scope();
  func_scope->parent = current_scope;
  current_scope = func_scope;

  // Process parameters
  Node* params = func_node->left;
  for (int i = 0; i < params->list->size; i++) {
    Node* param = params->list->items[i];
    Symbol sym;
    strcpy(sym.name, param->right->value);
    sym.location = i;
    sym.in_register = (i < 6);
    add_symbol(current_scope, sym);
  }

  // Generate function body
  codegen_block(func_node->right, emitter);

  // Emit return if not present
  if (last_instruction != OP_RET) {
    emitter->emit_load(6, 0);  // R6 = 0 (default return)
    emitter->emit_ret();
  }

  // Pop scope
  current_scope = func_scope->parent;
}
```

### 3.7 Function Call

**Language:**

```c
result = add(5, 3);
```

**Generated Bytecode:**

```
LOADI R0, 5
PUSH R0                (push arg1)
LOADI R0, 3
PUSH R0                (push arg2)
CALL add               (0x1000)
; After return, R6 has result
LOAD R_result, R6
```

**Code Generator:**

```cpp
void codegen_function_call(Node* call_node, Emitter* emitter) {
  char* func_name = call_node->value;
  Node* args = call_node->left;

  // Evaluate arguments right-to-left
  for (int i = args->list->size - 1; i >= 0; i--) {
    codegen_expression(args->list->items[i], emitter);  // Result in R0
    emitter->emit_push(0);  // Push R0
  }

  // Find function address
  uint16_t func_addr = lookup_function_address(func_name);

  // Emit call
  emitter->emit_call(func_addr);

  // Result is in R6
}
```

### 3.8 Array Declaration

**Language:**

```c
int arr[10];
```

**Generated Bytecode:**

```
ALLOC 40               (allocate 10 * 4 bytes)
LOAD R_arr_base, R6   (store heap base in arr variable)
```

**Code Generator:**

```cpp
void codegen_array_declaration(Node* arr_decl, Emitter* emitter) {
  char* arr_name = arr_decl->left->value;
  long arr_size = arr_decl->ivalue;  // Number of elements

  // Calculate allocation size (each element is 4 bytes)
  uint16_t alloc_size = (uint16_t)(arr_size * 4);

  Symbol sym;
  strcpy(sym.name, arr_name);
  sym.is_array = true;
  sym.array_size = arr_size;

  // Generate ALLOC
  emitter->emit_alloc(alloc_size);  // Result in R6

  if (current_scope->symbol_count < 6) {
    sym.location = current_scope->symbol_count;
    sym.in_register = true;
    emitter->emit_load(sym.location, 6);  // R[location] = R6
  } else {
    sym.location = current_scope->local_var_size;
    sym.in_register = false;
    emitter->emit_store_to_stack(sym.location, 6);
    current_scope->local_var_size += 4;
  }

  add_symbol(current_scope, sym);
}
```

### 3.9 Array Access

**Language:**

```c
x = arr[5];
arr[3] = 10;
```

**Generated Bytecode:**

```
; Read arr[5]
LOAD R0, R_arr_base   (R0 = base address)
LOADI R1, 20          (5 * 4 = 20 bytes offset)
ADD R0, R1            (R0 = base + offset)
LOAD_MEM R1, R0       (R1 = *(int*)R0)
LOAD R_x, R1

; Write arr[3] = 10
LOAD R0, R_arr_base
LOADI R1, 12          (3 * 4 = 12 bytes offset)
ADD R0, R1            (R0 = base + offset)
LOADI R1, 10
STORE R0, R1          (*(int*)R0 = R1)
```

**Code Generator:**

```cpp
void codegen_array_access(Node* access_node, Emitter* emitter) {
  // access_node->left: array name
  // access_node->right: index expression

  char* arr_name = access_node->left->value;
  Symbol* arr_sym = lookup_symbol(current_scope, arr_name);

  // Load array base
  if (arr_sym->in_register) {
    emitter->emit_load(0, arr_sym->location);
  } else {
    emitter->emit_load_from_stack(0, arr_sym->location);
  }

  // Evaluate index
  codegen_expression(access_node->right, emitter);  // Result in R0

  // Index is in R0, array base is in R_temp
  // We need to: offset = index * 4
  emitter->emit_push(0);  // Save index
  emitter->emit_loadi(1, 2);  // R1 = 2
  emitter->emit_shl(0, 1);  // R0 = index << 2 = index * 4

  // Now add array base
  emitter->emit_pop(1);  // R1 = saved base
  emitter->emit_add(0, 1);  // R0 = base + offset

  // R0 now contains the memory address
  // For read: emitter->emit_load_mem(target, 0)
  // For write: emitter->emit_store(0, value_reg)
}
```

## 4. EMITTER CLASS (Instruction Generator)

```cpp
class Emitter {
private:
  uint8_t* bytecode;
  uint16_t offset;
  uint16_t label_counter;
  std::map<uint16_t, uint16_t> label_positions;
  std::vector<uint16_t> fixup_list;  // Jumps needing address resolution

public:
  Emitter(uint16_t max_size = 65536) {
    bytecode = (uint8_t*)malloc(max_size);
    offset = 0;
    label_counter = 0;
  }

  uint16_t current_offset() { return offset; }

  uint16_t new_label() {
    return label_counter++;
  }

  void emit_label(uint16_t label) {
    label_positions[label] = offset;
  }

  void emit_instruction(uint8_t opcode, uint8_t arg1, uint8_t arg2) {
    if (offset + 3 <= 65536) {
      bytecode[offset] = opcode;
      bytecode[offset + 1] = arg1;
      bytecode[offset + 2] = arg2;
      offset += 3;
    }
  }

  // Convenience methods
  void emit_loadi(uint8_t reg, int8_t imm) {
    emit_instruction(OP_LOADI, reg, (uint8_t)imm);
  }

  void emit_add(uint8_t r1, uint8_t r2) {
    emit_instruction(OP_ADD, r1, r2);
  }

  void emit_jmp(uint16_t label) {
    // Placeholder; will be fixed up later
    uint16_t placeholder_offset = offset;
    emit_instruction(OP_JMP, 0x00, 0x00);
    fixup_list.push_back(placeholder_offset);
    // Later: resolve_fixups() fills in actual addresses
  }

  void resolve_fixups() {
    for (uint16_t fixup_offset : fixup_list) {
      // Decode which label this jump refers to
      // Fill in actual address
      // (Implementation depends on label tracking strategy)
    }
  }

  uint8_t* get_bytecode() { return bytecode; }
  uint16_t get_size() { return offset; }
};
```

## 5. COMPLETE EXAMPLE: Compile & Run

### Source Code

```
int sum_to_n(int n) {
  int sum = 0;
  int i = 1;
  while (i <= n) {
    sum = sum + i;
    i = i + 1;
  }
  return sum;
}

void main() {
  exec sum_to_n(5);
}
```

### Compilation Steps

1. **Lexical Analysis**: Tokens recognized
2. **Parse**: AST built
3. **Semantic Analysis**: Functions registered, types checked
4. **Code Generation**:

   ```
   Function table:
     [0] sum_to_n: bytecode starts at offset 0x0000

   Bytecode at 0x0000 (sum_to_n function):
     0x0000: LOADI R0, 0         (sum = 0)
     0x0003: LOADI R1, 1         (i = 1)
     0x0006: [LOOP] CMP R1, ARG1 (compare i vs n)
     0x0009: JGT 0x0018          (jump if i > n)
     0x000C: ADD R0, R1          (sum = sum + i)
     0x000F: LOADI R2, 1
     0x0012: ADD R1, R2          (i = i + 1)
     0x0015: JMP 0x0006
     0x0018: LOAD R6, R0         (return value)
     0x001B: RET

   Bytecode at 0x001E (main function):
     0x001E: LOADI R0, 5
     0x0021: PUSH R0
     0x0024: CALL 0x0000
     0x0027: PRINT R6
     0x002A: HALT
   ```

5. **Execution**: VM starts at main(), calls sum_to_n(5), outputs 15

---

## 6. INTEGRATION WITH EXISTING CODE

Your current pipeline has:

- `lexer.l` (Flex): Tokenization ✓
- `parser.y` (Yacc): Parsing ✓
- `semantic.c/h`: Type checking ✓
- `ast.c/h`: AST representation ✓

**To add code generation:**

1. Create `codegen.h`:

```cpp
#pragma once
#include "ast.h"
void codegen_program(Node* root, const char* output_file);
```

2. Create `codegen.c`:

```cpp
#include "codegen.h"
#include <stdio.h>

Emitter* emitter;

void codegen_program(Node* root, const char* output_file) {
  emitter = emitter_new(65536);

  // Walk AST and emit code
  codegen_node(root);

  // Resolve jumps
  emitter_resolve_fixups(emitter);

  // Write to file or SD card
  FILE* f = fopen(output_file, "wb");
  fwrite(emitter_get_bytecode(emitter), 1, emitter_get_size(emitter), f);
  fclose(f);
}
```

3. In `main.c`, after semantic analysis:

```cpp
analyze_program(ast_root);     // Existing
codegen_program(ast_root, "/sd/program.vm");  // New
```

---

**End of Compiler Design Document**
